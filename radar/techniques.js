const content = [
  {
    name: 'Contract Testing',
    ring: 'Assess',
    quadrant: 'Techniques',
    isNew: 'FALSE',
    status: 'Moved In',
    description: `
      <h4>Description</h4>
      <p>
      Contract testing is a methodology for ensuring that two separate systems (such as two microservices) are compatible and can communicate with one another. It captures the interactions that are exchanged between each service, storing them in a contract, which then can be used to verify that both parties adhere to it. Contract testing goes beyond schema testing, requiring both parties to come to a consensus on the allowed set of interactions and allowing for evolution over time.
      </p>
      <p>
        What sets this form of testing apart from other approaches that aim to achieve the same thing is that each system can be tested independently from the other and that the contract is generated by the code itself, meaning the contract is always kept up to date.
      </p>
      <p>One of the tools mostly used for contract testing is Pactflow</p>
      <h4>Pros:</h4>
      <ul>
        <li><strong>Fast</strong> Contract tests run fast and are not reliant on other systems Easy to maintain</li>
        Easy to maintain
      </ul>
      <h4>Cons:</h4>
      <li><strong>Sharing:</strong> Contracts have to be shared between producer and consumer</li>
      <h4>Conclusion:</h4>
      <p>Contract Testing is a great addition to any project that deals with large-scale and highly distributed application(s). Integration issues between consumers and providers can be detected early without the need for setting up expensive integration environments. We would definitely recommend assessing contract testing as a technique.</p>
    `,
  },
  {
    name: 'BDD',
    ring: 'Adopt',
    quadrant: 'Techniques',
    isNew: 'FALSE',
    status: 'No Change',
    description: `
      <h4>Description</h4>
      <p>
        <strong>BDD</strong> (Behavior Driven Development) is a technique intended to prove that the desired behaviour of the application works as part of the development cycle. Acceptance criteria are written as a test to be automated. This makes it one of the easier Test First Approaches. <br>
        The technique is mostly used to enable easier collaboration between developer, tester, and (business) users. Applying BDD focusses on creating testable user stories that require a lower cognitive load from the developer. <br>
        Most popular automation frameworks support a BDD workflow. Tools that explicitly focus on BDD include:
      </p>
      <p>
        Examples of popular BDD frameworks are
        <ul>
          <li>Cucumber / Specflow</li>
          <li>Behave / JBehave</li>
        </ul>
      </p>
      <h4>Pros:</h4>
      <ul>
        <li>BDD allows spec-files to serve as both living documented requirements and tests.</li>
        <li>BDD drives user stories to be clearly defined because of the testable acceptance criteria.</li>
        <li>BDD focusses on reducing functional complexity for the developers, reducing cognitive load.</li>
      </ul>
      <h4>Cons:</h4>
      <ul>
            <li>Doing BDD correctly is really difficult. It requires strong collaboration between developers, testers, and business stakeholders, which can be challenging to establish and maintain.</li>
            <li>BDD, in most projects, is often misused as merely a way to write tests in a human-readable language. Without the collaborative focus on shared understanding and behavior specification, it holds little value.</li>
            <li>In some projects, BDD is simplified to using Cucumber and is misinterpreted as a low-code automation solution, appealing to teams as a shortcut to start automating. However, BDD's purpose is not to simplify automation but to foster collaboration and ensure a shared understanding of the system's expected behaviors.</li>
      </ul>
      <h4>Conclusion:</h4>
      <p>
        While BDD is widely adopted, it is rarely done right. <br>
        In our experience, BDD is rarely applied for its intended purpose—facilitating collaboration and ensuring shared understanding between developers, testers, and business stakeholders. Instead, it often becomes an additional layer of complexity, where the Gherkin syntax adds little value beyond traditional testing approaches. <br>
        Where BDD is done right we see user stories delivered to production faster and a reduced need for other acceptance level tests. <br>
        We recommend BDD when it is supported by business stakeholders, developers and testers. In other circumstances it is a wasted effort.
      </p>
    `,
  },
  {
    name: 'TDD',
    ring: 'Assess',
    quadrant: 'Techniques',
    isNew: 'FALSE',
    status: 'No Change',
    description: `
      <h4>Description</h4>
      <p>
        <strong>TDD</strong> or Test Driven Development is a practice used in software development to make quality, neat, and errorless code, especially when there is change bound to happen later on. As the name suggests, TDD is a way to do development that is driven by tests rather than first writing your code and adding unit tests afterward.
      </p>
      <h4>Pros:</h4>
      <ul>
        <li><strong>Test coverage:</strong> By writing tests before you code, you know all your written code is covered by unit tests</li>
        <li><strong>Quality:</strong> The quality of your code will improve because you need to think about scenarios and functionality before you write a single line of code</li>
      </ul>
      <h4>Cons:</h4>
      <ul>
        <li><strong>Learning curve</strong> It can be difficult to start with TDD, it takes time and effort to invest in this technique.</li>
      </ul>
      <h4>Conclusion:</h4>
      <p>TDD can dramatically improve the quality of your code as it forces you to think about tests before actually writing code and gives you rapid feedback when making changes.  We would recommend evaluating if TDD fits within the context of your organization, e.g. if your product is relatively well-defined and doesn’t change in extreme forms very rapidly.</p>
    `,
  },
  {
    name: 'Visual Regression Testing',
    ring: 'Trial',
    quadrant: 'Techniques',
    isNew: 'FALSE',
    status: 'No Change',
    description: `
      <h4>Description</h4>
      <p>
       If your team or company has a static component library, performing Visual Regression tests can provide massive value by providing visual validation of these components on every iteration.  Obviously, you could detect these differences manually but sometimes they’re extremely small and it’s quite time-consuming. Most tools offer a pixel-by-pixel comparison and work similarly. The difficulty comes with searching for a threshold that’s a perfect tradeoff between not having flaky tests, missed regression, or having to update the snapshots all the time.
      </p>
      <p>
        Examples of popular visual testing tools are
        <ul>
          <li>Chromatic</li>
          <li>Percy</li>
          <li>Test tool implementations, e.g. Playwright, WebdriverIO</li>
          <li>Applitools</li>
        </ul>
      </p>
      <h4>Pros:</h4>
      <ul>
        <li><strong>Ease of Implementation:</strong> Many visual testing tools are simple to set up and integrate into existing workflows.</li>
        <li><strong>Automated Visual Monitoring:</strong> By using tools you can monitor visual regression more easily than by doing it manually</li>
      </ul>
      <h4>Cons:</h4>
      <ul>
        <li><strong>Flakiness:</strong> Visual comparisons can result in flaky tests if thresholds are not correctly set leading to time-consuming debugging tasks.</li>
        <li><strong>Pricing:</strong> High quality tools are often paid and doing a lot of comparisons could increase the licensing costs a lot.</li>
      </ul>
      <h4>Conclusion:</h4>
      <p>
        Visual Regression Testing can be very beneficial when implemented correctly, preventing unnoticed UI changes and improving overall design consistency. However, improper setup can turn it into a time sink.
        <br/>
        For teams using Storybook, visual testing is an especially natural fit, as it enables seamless validation of UI components in isolation. If your project includes a well-defined, static component library, investing in visual regression testing is highly recommended. Otherwise, teams may find better value in other QA activities.
      </p>
    `,
  },
  {
    name: 'Mutation testing',
    ring: 'Trial',
    quadrant: 'Techniques',
    isNew: 'FALSE',
    status: 'No Change',
    description: `
      <h4>Description</h4>
      <p>
        Conceptually, mutation testing is straightforward. Using specialized tools, small changes (mutations) are made to the source code of an application, creating a "mutant." When tests are executed against this mutant, the expectation is that one or more tests will fail, indicating that the mutation introduced an incorrect system behavior. This process is referred to as "killing the mutant." If no tests fail, it is a clear indication that the mutated part of the application lacks sufficient test coverage. Mutation testing is often referred to as "testing the tests."
      </p>
      <p>
        Here are a few examples of mutation testing tools (not an exhaustive list):
        <ul>
          <li>PIT (pitest.org)</li>
          <li>Arcmutate (arcmutate.com)</li>
          <li>Stryker Mutator (stryker-mutator.io)</li>
        </ul>
      </p>
      <h4>Pros:</h4>
      <ul>
        <li><strong>Ensures Test Quality:</strong> Mutation testing helps determine not just test coverage but also test effectiveness, ensuring your tests can detect actual faults in the code.</li>
        <li><strong>Identifies Weak Tests:</strong> It can highlight weak or redundant tests that might be passing but are not effectively validating the application's behavior.</li>
      </ul>
      <h4>Cons:</h4>
      <ul>
        <li>Mutation testing can be computationally expensive, especially in large projects, as it requires running the test suite multiple times for each mutation.</li>
        <li>It may require additional configuration or tuning to integrate seamlessly with your existing testing pipelines</li>
      </ul>
      <h4>Conclusion:</h4>
      <p>
        Mutation Testing is an amazing technique to validate if you can actually rely on your tests to inform you of changed behavior. Traditional test coverage (i.e. line, statement, branch, etc.) measures only which code is executed by your tests. It does not check that your tests are actually able to detect faults in the executed code. It is therefore only able to identify code that is definitely not tested.
        Mutation testing is much better, as it is actually able to detect whether each
        statement is meaningfully tested. Therefore giving an accurate report on the quality of your tests.
        <br/>We would definitely recommend checking it out!
      </p>
    `,
  },
  {
    name: 'Component testing',
    ring: 'Trial',
    quadrant: 'Techniques',
    isNew: 'FALSE',
    status: 'FALSE',
    description: `
      <h4>Description</h4>
      <p>
       Component testing focuses on verifying the functionality of individual components or modules in isolation, independent of the overall system. This approach is particularly effective in modern, modular development practices, such as those using frameworks like React, Angular, or Vue. By isolating components, developers can ensure that each part behaves as expected, enabling faster and more reliable integration into larger systems.
      </p>
      <h4>Pros:</h4>
      <ul>
      <li><strong>Proven Effectiveness:</strong> Ensures each component functions correctly, reducing bugs during integration.</li>
      <li><strong>Fast Feedback Loop:</strong> Quickly detects issues, enabling rapid fixes during development.</li>
      <li><strong>Improved Debugging:</strong> Failures are scoped to the individual component, simplifying root-cause analysis.</li>
      </ul>
      <h4>Cons:</h4>
      <ul>
      <li><strong>Requires Complementary Testing:</strong> Must be supplemented with integration and end-to-end tests to ensure system-wide functionality.</li>
      <li><strong>Initial Setup Overhead:</strong> Requires tools and mocks for setup, though this effort pays off in the long term.</li>
      <li><strong>Limited Context:</strong> Testing in isolation might miss issues caused by component interactions.</li>
      </ul>
      <h4>Conclusion:</h4>
      <p>Component testing is a proven practice that delivers significant value, especially in projects using modular architectures. However, it should complement, not replace, unit testing (UT). Each layer of testing has its own purpose, and overlapping coverage between unit and component tests should be avoided to prevent redundancy. Additionally, component testing can be effectively combined with visual testing to verify both behavior and UI consistency. We strongly recommend adopting component testing for immediate use wherever it fits project requirements, as part of a comprehensive and efficient testing strategy.</p>
    `,
  },
]

exports.techniques = {
  content,
}
